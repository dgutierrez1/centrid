import { pgTable, uuid, text, integer, timestamp, real, jsonb, index, unique, customType } from 'drizzle-orm/pg-core';

/**
 * Database Schema for Centrid MVP
 *
 * 7 core tables:
 * - user_profiles: Extended user data beyond auth.users
 * - folders: Hierarchical folder structure for documents
 * - documents: File metadata with full-text search
 * - document_chunks: RAG text segments
 * - agent_requests: AI agent execution tracking
 * - agent_sessions: Multi-turn conversation management
 * - usage_events: Usage tracking for billing
 */

// Custom tsvector type for full-text search
const tsvector = customType<{ data: string }>({
  dataType() {
    return 'tsvector';
  },
});

// ============================================================================
// 1. USER_PROFILES TABLE
// ============================================================================

export const userProfiles = pgTable('user_profiles', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull().unique(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  firstName: text('first_name').notNull(), // Required: user must provide during signup for personalization
  lastName: text('last_name').notNull(), // Required: user must provide during signup for personalization
  planType: text('plan_type').notNull().default('free'),
  usageCount: integer('usage_count').notNull().default(0),
  subscriptionStatus: text('subscription_status').notNull().default('active'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('user_profiles_user_id_idx').on(table.userId),
}));

// ============================================================================
// 2. FOLDERS TABLE
// ============================================================================

export const folders = pgTable('folders', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE
  name: text('name').notNull(),
  parentFolderId: uuid('parent_folder_id'), // Self-referential FK, null = root
  path: text('path').notNull(), // Computed path from hierarchy
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('folders_user_id_idx').on(table.userId),
  parentFolderIdIdx: index('folders_parent_folder_id_idx').on(table.parentFolderId),
  uniqueNameInParent: unique('folders_unique_name_in_parent').on(table.userId, table.parentFolderId, table.name),
}));

// ============================================================================
// 3. DOCUMENTS TABLE
// ============================================================================

export const documents = pgTable('documents', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  folderId: uuid('folder_id'), // FK to folders(id) ON DELETE CASCADE, null = root level
  name: text('name').notNull(), // Filename with extension
  storagePath: text('storage_path').notNull(), // Path in Supabase Storage
  contentText: text('content_text'), // Cached markdown content for fast access
  fileSize: integer('file_size').notNull(),
  mimeType: text('mime_type').notNull(), // 'text/markdown' or 'text/plain'
  path: text('path').notNull(), // Computed path for breadcrumbs
  version: integer('version').notNull().default(0), // Optimistic locking
  indexingStatus: text('indexing_status').notNull().default('pending'), // 'pending', 'in_progress', 'completed', 'failed'
  // searchVector auto-generated by trigger (see triggers.searchVectors below)
  searchVector: tsvector('search_vector'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('documents_user_id_idx').on(table.userId),
  folderIdIdx: index('documents_folder_id_idx').on(table.folderId),
  indexingStatusIdx: index('documents_indexing_status_idx').on(table.indexingStatus),
  uniqueNameInFolder: unique('documents_unique_name_in_folder').on(table.userId, table.folderId, table.name),
  createdAtIdx: index('documents_created_at_idx').on(table.createdAt),
}));

// ============================================================================
// 4. DOCUMENT_CHUNKS TABLE
// ============================================================================

export const documentChunks = pgTable('document_chunks', {
  id: uuid('id').primaryKey().defaultRandom(),
  documentId: uuid('document_id').notNull(), // FK to documents(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  content: text('content').notNull(), // Markdown text (400-500 tokens)
  position: integer('position').notNull(), // Order in original document (0, 1, 2, ...)
  // searchVector auto-generated by trigger (see triggers.searchVectors below)
  searchVector: tsvector('search_vector'),
  // embedding will be added via custom SQL (pgvector extension required)
  // embedding: vector('embedding', { dimensions: 1536 }), // OpenAI text-embedding-3-small
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  documentIdIdx: index('document_chunks_document_id_idx').on(table.documentId),
  positionIdx: index('document_chunks_position_idx').on(table.documentId, table.position),
  uniquePosition: unique('document_chunks_document_id_position_unique').on(table.documentId, table.position),
}));

// ============================================================================
// 5. AGENT_REQUESTS TABLE
// ============================================================================

export const agentRequests = pgTable('agent_requests', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  agentType: text('agent_type').notNull(),
  content: text('content').notNull(),
  status: text('status').notNull().default('pending'),
  progress: real('progress').notNull().default(0),
  results: jsonb('results'),
  tokenCost: integer('token_cost'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('agent_requests_user_id_idx').on(table.userId),
  statusIdx: index('agent_requests_status_idx').on(table.status),
  createdAtIdx: index('agent_requests_created_at_idx').on(table.createdAt),
}));

// ============================================================================
// 6. AGENT_SESSIONS TABLE
// ============================================================================

export const agentSessions = pgTable('agent_sessions', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  requestChain: jsonb('request_chain').notNull().default([]),
  contextState: jsonb('context_state'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('agent_sessions_user_id_idx').on(table.userId),
  updatedAtIdx: index('agent_sessions_updated_at_idx').on(table.updatedAt),
}));

// ============================================================================
// 7. USAGE_EVENTS TABLE
// ============================================================================

export const usageEvents = pgTable('usage_events', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  eventType: text('event_type').notNull(),
  tokensUsed: integer('tokens_used'),
  cost: real('cost'),
  metadata: jsonb('metadata'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('usage_events_user_id_idx').on(table.userId),
  createdAtIdx: index('usage_events_created_at_idx').on(table.createdAt),
  eventTypeIdx: index('usage_events_event_type_idx').on(table.eventType),
}));

// ============================================================================
// RLS POLICIES (Applied via migration SQL)
// ============================================================================

// These SQL statements will be added to migrations for RLS policies
// Drizzle ORM doesn't have native RLS support, so we define these separately

export const rlsPolicies = {
  userProfiles: `
    -- Enable RLS on user_profiles
    ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;

    -- Users can view own profile
    CREATE POLICY "Users can view own profile"
      ON user_profiles FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can update own profile
    CREATE POLICY "Users can update own profile"
      ON user_profiles FOR UPDATE
      USING (auth.uid() = user_id);
  `,

  folders: `
    -- Enable RLS on folders
    ALTER TABLE folders ENABLE ROW LEVEL SECURITY;

    -- Users can read only their own folders
    CREATE POLICY "Users can read own folders"
      ON folders FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can insert folders into their own hierarchy
    CREATE POLICY "Users can create own folders"
      ON folders FOR INSERT
      WITH CHECK (auth.uid() = user_id);

    -- Users can update their own folders
    CREATE POLICY "Users can update own folders"
      ON folders FOR UPDATE
      USING (auth.uid() = user_id);

    -- Users can delete their own folders (cascade to children via FK)
    CREATE POLICY "Users can delete own folders"
      ON folders FOR DELETE
      USING (auth.uid() = user_id);
  `,

  documents: `
    -- Enable RLS on documents
    ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

    -- Users can view own documents
    CREATE POLICY "Users can view own documents"
      ON documents FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can insert own documents
    CREATE POLICY "Users can insert own documents"
      ON documents FOR INSERT
      WITH CHECK (auth.uid() = user_id);

    -- Users can update own documents
    CREATE POLICY "Users can update own documents"
      ON documents FOR UPDATE
      USING (auth.uid() = user_id);

    -- Users can delete own documents
    CREATE POLICY "Users can delete own documents"
      ON documents FOR DELETE
      USING (auth.uid() = user_id);
  `,

  documentChunks: `
    -- Enable RLS on document_chunks
    ALTER TABLE document_chunks ENABLE ROW LEVEL SECURITY;

    -- Users can view chunks of own documents
    CREATE POLICY "Users can view chunks of own documents"
      ON document_chunks FOR SELECT
      USING (EXISTS (
        SELECT 1 FROM documents
        WHERE documents.id = document_chunks.document_id
        AND documents.user_id = auth.uid()
      ));

    -- Users can insert chunks for own documents
    CREATE POLICY "Users can insert chunks for own documents"
      ON document_chunks FOR INSERT
      WITH CHECK (EXISTS (
        SELECT 1 FROM documents
        WHERE documents.id = document_chunks.document_id
        AND documents.user_id = auth.uid()
      ));

    -- Users can update chunks of own documents
    CREATE POLICY "Users can update chunks of own documents"
      ON document_chunks FOR UPDATE
      USING (EXISTS (
        SELECT 1 FROM documents
        WHERE documents.id = document_chunks.document_id
        AND documents.user_id = auth.uid()
      ));

    -- Users can delete chunks of own documents
    CREATE POLICY "Users can delete chunks of own documents"
      ON document_chunks FOR DELETE
      USING (EXISTS (
        SELECT 1 FROM documents
        WHERE documents.id = document_chunks.document_id
        AND documents.user_id = auth.uid()
      ));
  `,

  agentRequests: `
    -- Enable RLS on agent_requests
    ALTER TABLE agent_requests ENABLE ROW LEVEL SECURITY;

    -- Users can view own requests
    CREATE POLICY "Users can view own agent requests"
      ON agent_requests FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can insert own requests
    CREATE POLICY "Users can insert own agent requests"
      ON agent_requests FOR INSERT
      WITH CHECK (auth.uid() = user_id);

    -- Users can update own requests
    CREATE POLICY "Users can update own agent requests"
      ON agent_requests FOR UPDATE
      USING (auth.uid() = user_id);

    -- Users can delete own requests
    CREATE POLICY "Users can delete own agent requests"
      ON agent_requests FOR DELETE
      USING (auth.uid() = user_id);
  `,

  agentSessions: `
    -- Enable RLS on agent_sessions
    ALTER TABLE agent_sessions ENABLE ROW LEVEL SECURITY;

    -- Users can view own sessions
    CREATE POLICY "Users can view own agent sessions"
      ON agent_sessions FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can insert own sessions
    CREATE POLICY "Users can insert own agent sessions"
      ON agent_sessions FOR INSERT
      WITH CHECK (auth.uid() = user_id);

    -- Users can update own sessions
    CREATE POLICY "Users can update own agent sessions"
      ON agent_sessions FOR UPDATE
      USING (auth.uid() = user_id);

    -- Users can delete own sessions
    CREATE POLICY "Users can delete own agent sessions"
      ON agent_sessions FOR DELETE
      USING (auth.uid() = user_id);
  `,

  usageEvents: `
    -- Enable RLS on usage_events
    ALTER TABLE usage_events ENABLE ROW LEVEL SECURITY;

    -- Users can view own usage events
    CREATE POLICY "Users can view own usage events"
      ON usage_events FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can insert own usage events
    CREATE POLICY "Users can insert own usage events"
      ON usage_events FOR INSERT
      WITH CHECK (auth.uid() = user_id);

    -- No UPDATE or DELETE allowed (immutable audit trail)
  `,
};

// ============================================================================
// TRIGGERS (Applied via migration SQL)
// ============================================================================

export const triggers = {
  // Automatic updated_at timestamp update
  updateUpdatedAt: `
    CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS $$
    BEGIN
      NEW.updated_at = NOW();
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    -- Apply to all tables with updated_at
    CREATE TRIGGER update_user_profiles_updated_at
      BEFORE UPDATE ON user_profiles
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();

    CREATE TRIGGER update_folders_updated_at
      BEFORE UPDATE ON folders
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();

    CREATE TRIGGER update_documents_updated_at
      BEFORE UPDATE ON documents
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();

    CREATE TRIGGER update_document_chunks_updated_at
      BEFORE UPDATE ON document_chunks
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();

    CREATE TRIGGER update_agent_requests_updated_at
      BEFORE UPDATE ON agent_requests
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();

    CREATE TRIGGER update_agent_sessions_updated_at
      BEFORE UPDATE ON agent_sessions
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();
  `,

  // Auto-create user profile on auth.users insert
  // NOTE: For MVP account foundation, Edge Function handles profile creation explicitly
  // with atomic rollback logic (research.md). This trigger is DISABLED to avoid conflicts.
  // Re-enable post-MVP if Edge Function approach is replaced.
  autoCreateProfile: `
    -- DISABLED: Edge Function handles profile creation with rollback
    -- CREATE OR REPLACE FUNCTION create_user_profile()
    -- RETURNS TRIGGER AS $$
    -- BEGIN
    --   INSERT INTO user_profiles (user_id, first_name, last_name)
    --   VALUES (
    --     NEW.id,
    --     NEW.raw_user_meta_data->>'first_name',
    --     NEW.raw_user_meta_data->>'last_name'
    --   );
    --   RETURN NEW;
    -- END;
    -- $$ LANGUAGE plpgsql;

    -- CREATE TRIGGER on_auth_user_created
    --   AFTER INSERT ON auth.users
    --   FOR EACH ROW
    --   EXECUTE FUNCTION create_user_profile();
  `,

  // Full-text search vector generation
  // NOTE: tsvector columns defined in schema using customType
  // Triggers and indexes applied via this SQL
  searchVectors: `
    -- Create GIN indexes for full-text search performance
    CREATE INDEX IF NOT EXISTS documents_search_vector_idx
      ON documents USING GIN (search_vector);

    CREATE INDEX IF NOT EXISTS document_chunks_search_vector_idx
      ON document_chunks USING GIN (search_vector);

    -- Create triggers to auto-update search vectors on INSERT/UPDATE
    DROP TRIGGER IF EXISTS update_documents_search_vector ON documents;
    CREATE TRIGGER update_documents_search_vector
      BEFORE INSERT OR UPDATE OF content_text ON documents
      FOR EACH ROW
      EXECUTE FUNCTION tsvector_update_trigger(search_vector, 'pg_catalog.english', content_text);

    DROP TRIGGER IF EXISTS update_chunks_search_vector ON document_chunks;
    CREATE TRIGGER update_chunks_search_vector
      BEFORE INSERT OR UPDATE OF content ON document_chunks
      FOR EACH ROW
      EXECUTE FUNCTION tsvector_update_trigger(search_vector, 'pg_catalog.english', content);
  `,
};

// ============================================================================
// CASCADE DELETE FOREIGN KEYS
// ============================================================================
// These foreign keys to auth.users must be added separately since auth schema
// is not managed by Drizzle. Apply this SQL after pushing schema with drizzle-kit.
// Usage: Run cascadeDeleteSQL via database client or Supabase Dashboard SQL Editor

export const cascadeDeleteSQL = `
-- Add CASCADE DELETE foreign keys for GDPR compliance

-- User Profiles
ALTER TABLE user_profiles
  DROP CONSTRAINT IF EXISTS user_profiles_user_id_fkey;
ALTER TABLE user_profiles
  ADD CONSTRAINT user_profiles_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Folders (user ownership + self-referential hierarchy)
ALTER TABLE folders
  DROP CONSTRAINT IF EXISTS folders_user_id_fkey;
ALTER TABLE folders
  ADD CONSTRAINT folders_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

ALTER TABLE folders
  DROP CONSTRAINT IF EXISTS folders_parent_folder_id_fkey;
ALTER TABLE folders
  ADD CONSTRAINT folders_parent_folder_id_fkey
  FOREIGN KEY (parent_folder_id) REFERENCES folders(id) ON DELETE CASCADE;

-- Documents (user ownership + folder hierarchy)
ALTER TABLE documents
  DROP CONSTRAINT IF EXISTS documents_user_id_fkey;
ALTER TABLE documents
  ADD CONSTRAINT documents_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

ALTER TABLE documents
  DROP CONSTRAINT IF EXISTS documents_folder_id_fkey;
ALTER TABLE documents
  ADD CONSTRAINT documents_folder_id_fkey
  FOREIGN KEY (folder_id) REFERENCES folders(id) ON DELETE CASCADE;

-- Document Chunks (cascade from documents)
ALTER TABLE document_chunks
  DROP CONSTRAINT IF EXISTS document_chunks_document_id_fkey;
ALTER TABLE document_chunks
  ADD CONSTRAINT document_chunks_document_id_fkey
  FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE;

-- Agent Requests
ALTER TABLE agent_requests
  DROP CONSTRAINT IF EXISTS agent_requests_user_id_fkey;
ALTER TABLE agent_requests
  ADD CONSTRAINT agent_requests_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Agent Sessions
ALTER TABLE agent_sessions
  DROP CONSTRAINT IF EXISTS agent_sessions_user_id_fkey;
ALTER TABLE agent_sessions
  ADD CONSTRAINT agent_sessions_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Usage Events
ALTER TABLE usage_events
  DROP CONSTRAINT IF EXISTS usage_events_user_id_fkey;
ALTER TABLE usage_events
  ADD CONSTRAINT usage_events_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Verify CASCADE constraints
SELECT
  conname AS constraint_name,
  conrelid::regclass AS table_name,
  confrelid::regclass AS references_table
FROM pg_constraint
WHERE confdeltype = 'c'  -- 'c' = CASCADE
ORDER BY conname;
`;

// ============================================================================
// PGVECTOR EXTENSION (Vector Embeddings for RAG)
// ============================================================================
// Enable pgvector extension and add embedding column to document_chunks
// Must be run after initial schema push

export const pgvectorSQL = `
-- Enable pgvector extension for vector similarity search
CREATE EXTENSION IF NOT EXISTS vector;

-- Add embedding column to document_chunks table
ALTER TABLE document_chunks
ADD COLUMN IF NOT EXISTS embedding vector(1536);

-- Create HNSW index for fast vector similarity search
CREATE INDEX IF NOT EXISTS document_chunks_embedding_idx
ON document_chunks
USING hnsw (embedding vector_cosine_ops);
`;

// ============================================================================
// REALTIME PUBLICATION
// ============================================================================
// Enable realtime for tables that need real-time subscriptions
// Must be run after schema push

export const realtimePublicationSQL = `
-- Enable realtime for folders and documents tables
-- Uses SET TABLE instead of ADD TABLE for idempotency
-- SET replaces the table list, so it's safe to run multiple times
ALTER PUBLICATION supabase_realtime SET TABLE folders, documents;

-- CRITICAL: Set REPLICA IDENTITY to FULL for DELETE events
-- Default behavior: DELETE events only include primary key (id)
-- FULL behavior: DELETE events include all columns (including user_id)
-- Why needed: Subscription filter "user_id=eq.[user_id]" requires user_id in DELETE events
ALTER TABLE folders REPLICA IDENTITY FULL;
ALTER TABLE documents REPLICA IDENTITY FULL;
`;
