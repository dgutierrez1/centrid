import { pgTable, uuid, text, integer, timestamp, real, jsonb, index, unique, customType, boolean } from 'drizzle-orm/pg-core';
import type { ContentBlock } from '../types/graphql.ts';

/**
 * Database Schema for Centrid MVP
 *
 * 7 core tables:
 * - user_profiles: Extended user data beyond auth.users
 * - folders: Hierarchical folder structure for documents
 * - documents: File metadata with full-text search
 * - document_chunks: RAG text segments
 * - agent_requests: AI agent execution tracking
 * - agent_sessions: Multi-turn conversation management
 * - usage_events: Usage tracking for billing
 */

// Custom tsvector type for full-text search
const tsvector = customType<{ data: string }>({
  dataType() {
    return 'tsvector';
  },
});

// Custom vector type for pgvector embeddings
const vector = customType<{ data: number[]; driverData: string }>({
  dataType() {
    return 'vector(768)'; // OpenAI text-embedding-3-small
  },
  toDriver(value: number[]): string {
    return JSON.stringify(value);
  },
  fromDriver(value: string): number[] {
    return JSON.parse(value);
  },
});

// Custom ContentBlock array type for message content (typed JSONB)
const contentBlockArray = customType<{ data: ContentBlock[]; driverData: string }>({
  dataType() {
    return 'jsonb';
  },
  toDriver(value: ContentBlock[]): string {
    return JSON.stringify(value);
  },
  fromDriver(value: string): ContentBlock[] {
    if (typeof value === 'string') {
      return JSON.parse(value) as ContentBlock[];
    }
    // Already parsed by pg driver
    return value as ContentBlock[];
  },
});

// ============================================================================
// 1. USER_PROFILES TABLE
// ============================================================================

export const userProfiles = pgTable('user_profiles', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull().unique(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  firstName: text('first_name').notNull(), // Required: user must provide during signup for personalization
  lastName: text('last_name').notNull(), // Required: user must provide during signup for personalization
  planType: text('plan_type').notNull().default('free'),
  usageCount: integer('usage_count').notNull().default(0),
  subscriptionStatus: text('subscription_status').notNull().default('active'),
  createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('user_profiles_user_id_idx').on(table.userId),
}));

// ============================================================================
// 2. FOLDERS TABLE
// ============================================================================

export const folders = pgTable('folders', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE
  name: text('name').notNull(),
  parentFolderId: uuid('parent_folder_id'), // Self-referential FK, null = root
  path: text('path').notNull(), // Computed path from hierarchy
  createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('folders_user_id_idx').on(table.userId),
  parentFolderIdIdx: index('folders_parent_folder_id_idx').on(table.parentFolderId),
  uniqueNameInParent: unique('folders_unique_name_in_parent').on(table.userId, table.parentFolderId, table.name),
}));

// ============================================================================
// 3. DOCUMENTS TABLE
// ============================================================================

export const documents = pgTable('documents', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  folderId: uuid('folder_id'), // FK to folders(id) ON DELETE CASCADE, null = root level
  name: text('name').notNull(), // Filename with extension
  storagePath: text('storage_path').notNull(), // Path in Supabase Storage
  contentText: text('content_text'), // Cached markdown content for fast access
  fileSize: integer('file_size').notNull(),
  mimeType: text('mime_type').notNull(), // 'text/markdown' or 'text/plain'
  path: text('path').notNull(), // Computed path for breadcrumbs
  version: integer('version').notNull().default(0), // Optimistic locking
  indexingStatus: text('indexing_status').notNull().default('pending'), // 'pending', 'in_progress', 'completed', 'failed'
  // searchVector auto-generated by trigger (see triggers.searchVectors below)
  searchVector: tsvector('search_vector'),
  createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('documents_user_id_idx').on(table.userId),
  folderIdIdx: index('documents_folder_id_idx').on(table.folderId),
  indexingStatusIdx: index('documents_indexing_status_idx').on(table.indexingStatus),
  uniqueNameInFolder: unique('documents_unique_name_in_folder').on(table.userId, table.folderId, table.name),
  createdAtIdx: index('documents_created_at_idx').on(table.createdAt),
}));

// ============================================================================
// 4. DOCUMENT_CHUNKS TABLE
// ============================================================================

export const documentChunks = pgTable('document_chunks', {
  id: uuid('id').primaryKey().defaultRandom(),
  documentId: uuid('document_id').notNull(), // FK to documents(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  content: text('content').notNull(), // Markdown text (400-500 tokens)
  position: integer('position').notNull(), // Order in original document (0, 1, 2, ...)
  // searchVector auto-generated by trigger (see triggers.searchVectors below)
  searchVector: tsvector('search_vector'),
  // embedding will be added via custom SQL (pgvector extension required)
  // embedding: vector('embedding', { dimensions: 1536 }), // OpenAI text-embedding-3-small
  createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => ({
  documentIdIdx: index('document_chunks_document_id_idx').on(table.documentId),
  positionIdx: index('document_chunks_position_idx').on(table.documentId, table.position),
  uniquePosition: unique('document_chunks_document_id_position_unique').on(table.documentId, table.position),
}));

// ============================================================================
// 5. AGENT_REQUESTS TABLE
// ============================================================================

export const agentRequests = pgTable('agent_requests', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  threadId: uuid('thread_id').notNull(), // NEW: Link to thread
  triggeringMessageId: uuid('triggering_message_id').notNull(), // NEW: Which user message triggered this request
  responseMessageId: uuid('response_message_id'), // NEW: Assistant response message (set at stream end)
  agentType: text('agent_type').notNull(),
  content: text('content').notNull(),
  status: text('status').notNull().default('pending'),
  progress: real('progress').notNull().default(0),
  results: jsonb('results'),
  checkpoint: jsonb('checkpoint'), // NEW: Checkpoint for tool approval suspend/resume
  tokenCost: integer('token_cost'), // Keep existing
  createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
  completedAt: timestamp('completed_at', { withTimezone: true, mode: 'string' }), // NEW: When request finished
}, (table) => ({
  userIdIdx: index('agent_requests_user_id_idx').on(table.userId),
  threadIdIdx: index('agent_requests_thread_id_idx').on(table.threadId), // NEW
  triggeringMessageIdx: index('agent_requests_triggering_message_idx').on(table.triggeringMessageId), // NEW
  statusIdx: index('agent_requests_status_idx').on(table.status),
  createdAtIdx: index('agent_requests_created_at_idx').on(table.createdAt),
}));

// ============================================================================
// 5.5 AGENT_EXECUTION_EVENTS TABLE - Real-time Event Streaming
// ============================================================================

export const agentExecutionEvents = pgTable('agent_execution_events', {
  id: uuid('id').primaryKey().defaultRandom(),
  requestId: uuid('request_id').notNull(), // FK to agent_requests(id) ON DELETE CASCADE
  type: text('type').notNull(), // 'text_chunk', 'tool_call', 'completion', 'error'
  data: jsonb('data').notNull(), // Event payload
  createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => ({
  requestIdIdx: index('agent_execution_events_request_id_idx').on(table.requestId),
  requestIdCreatedAtIdx: index('agent_execution_events_request_id_created_at_idx').on(table.requestId, table.createdAt),
  typeIdx: index('agent_execution_events_type_idx').on(table.type),
}));

// ============================================================================
// 6. AGENT_SESSIONS TABLE
// ============================================================================

export const agentSessions = pgTable('agent_sessions', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  requestChain: jsonb('request_chain').notNull().default([]),
  contextState: jsonb('context_state'),
  createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('agent_sessions_user_id_idx').on(table.userId),
  updatedAtIdx: index('agent_sessions_updated_at_idx').on(table.updatedAt),
}));

// ============================================================================
// 7. USAGE_EVENTS TABLE
// ============================================================================

export const usageEvents = pgTable('usage_events', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  eventType: text('event_type').notNull(),
  tokensUsed: integer('tokens_used'),
  cost: real('cost'),
  metadata: jsonb('metadata'),
  createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('usage_events_user_id_idx').on(table.userId),
  createdAtIdx: index('usage_events_created_at_idx').on(table.createdAt),
  eventTypeIdx: index('usage_events_event_type_idx').on(table.eventType),
}));

// ============================================================================
// 8. THREADS TABLE (Agent System)
// ============================================================================

export const threads = pgTable('threads', {
  id: uuid('id').primaryKey().defaultRandom(),
  ownerUserId: uuid('owner_user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE
  parentThreadId: uuid('parent_thread_id'), // Self-referential for branches
  branchTitle: text('branch_title'), // Title for branch threads
  creator: text('creator').notNull(), // 'user' or 'agent'
  createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => ({
  ownerUserIdIdx: index('idx_threads_owner_user_id').on(table.ownerUserId),
  parentThreadIdIdx: index('idx_threads_parent_thread_id').on(table.parentThreadId),
  createdAtIdx: index('idx_threads_created_at').on(table.createdAt),
}));

// ============================================================================
// 9. MESSAGES TABLE (Agent System)
// ============================================================================

export const messages = pgTable('messages', {
  id: uuid('id').primaryKey().defaultRandom(),
  threadId: uuid('thread_id').notNull(), // FK to threads(id) ON DELETE CASCADE
  ownerUserId: uuid('owner_user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE
  role: text('role').notNull(), // 'user' or 'assistant'
  content: contentBlockArray('content').notNull(), // ContentBlock[] with type safety
  toolCalls: jsonb('tool_calls').default([]),
  tokensUsed: integer('tokens_used').default(0),
  timestamp: timestamp('timestamp', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
  requestId: uuid('request_id'), // FK to agent_requests(id) ON DELETE SET NULL (only set for user messages)
  idempotencyKey: uuid('idempotency_key').unique(), // For deduplication across optimistic updates and real-time sync
}, (table) => ({
  threadIdIdx: index('idx_messages_thread_id').on(table.threadId),
  threadTimestampIdx: index('idx_messages_thread_id_timestamp').on(table.threadId, table.timestamp),
  ownerUserIdIdx: index('idx_messages_owner_user_id').on(table.ownerUserId),
  createdAtIdx: index('idx_messages_created_at').on(table.timestamp),
  requestIdIdx: index('idx_messages_request_id').on(table.requestId),
}));

// ============================================================================
// 10. AGENT_TOOL_CALLS TABLE (Agent System)
// ============================================================================

export const agentToolCalls = pgTable('agent_tool_calls', {
  id: uuid('id').primaryKey().defaultRandom(),
  messageId: uuid('message_id').notNull(), // FK to messages(id) ON DELETE CASCADE
  threadId: uuid('thread_id').notNull(), // FK to threads(id) ON DELETE CASCADE
  ownerUserId: uuid('owner_user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE
  requestId: uuid('request_id'), // NEW: FK to agent_requests(id) ON DELETE CASCADE (optional, set later)
  toolName: text('tool_name').notNull(), // 'write_file', 'create_branch', etc
  toolInput: jsonb('tool_input').notNull(),
  approvalStatus: text('approval_status').default('pending'), // 'pending', 'approved', 'rejected'
  toolOutput: jsonb('tool_output'), // Result of tool execution
  rejectionReason: text('rejection_reason'), // Why tool was rejected
  revisionCount: integer('revision_count').default(0), // Number of rejection + retry cycles
  revisionHistory: jsonb('revision_history').default([]), // NEW: Track revision attempts
  timestamp: timestamp('timestamp', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => ({
  idIdx: index('idx_agent_tool_calls_id').on(table.id),
  threadIdIdx: index('idx_agent_tool_calls_thread_id').on(table.threadId),
  messageIdIdx: index('idx_agent_tool_calls_message_id').on(table.messageId),
  requestIdIdx: index('idx_agent_tool_calls_request_id').on(table.requestId), // NEW
  approvalStatusIdx: index('idx_agent_tool_calls_approval_status').on(table.approvalStatus),
  ownerUserIdIdx: index('idx_agent_tool_calls_owner_user_id').on(table.ownerUserId),
  createdAtIdx: index('idx_agent_tool_calls_created_at').on(table.timestamp),
}));

// ============================================================================
// 11. CONTEXT_REFERENCES TABLE (Agent System)
// ============================================================================

export const contextReferences = pgTable('context_references', {
  id: uuid('id').primaryKey().defaultRandom(),
  threadId: uuid('thread_id').notNull(), // FK to threads(id) ON DELETE CASCADE
  ownerUserId: uuid('owner_user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE
  entityType: text('entity_type').notNull(), // 'file', 'document', 'thread', etc
  entityReference: text('entity_reference').notNull(), // path or ID of referenced entity
  source: text('source').notNull(), // 'user-added', 'agent-added', 'inherited', etc
  priorityTier: integer('priority_tier').default(1), // Higher = more important for context
  addedAt: timestamp('added_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => ({
  threadIdIdx: index('idx_context_references_thread_id').on(table.threadId),
  ownerUserIdIdx: index('idx_context_references_owner_user_id').on(table.ownerUserId),
  entityTypeIdx: index('idx_context_references_entity_type').on(table.entityType),
}));

// ============================================================================
// 12. FILES TABLE (Agent System)
// ============================================================================

export const files = pgTable('files', {
  id: uuid('id').primaryKey().defaultRandom(),
  ownerUserId: uuid('owner_user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE
  name: text('name').notNull(), // Filename with extension (source of truth)
  path: text('path').notNull(), // Full path computed from folder hierarchy + name
  content: text('content').notNull(), // File content
  // Optional folder organization
  folderId: uuid('folder_id'), // FK to folders(id) ON DELETE SET NULL
  // Semantic search integration
  shadowDomainId: uuid('shadow_domain_id'), // FK to shadow_entities(id) ON DELETE SET NULL
  // Storage metadata
  storagePath: text('storage_path'), // Supabase Storage path for large files
  fileSize: integer('file_size'), // File size in bytes
  mimeType: text('mime_type'), // MIME type
  indexingStatus: text('indexing_status').default('pending'), // 'pending', 'completed', 'failed'
  // Provenance tracking
  source: text('source').default('user-uploaded'), // 'ai-generated', 'user-uploaded'
  isAIGenerated: boolean('is_ai_generated').default(false), // Track AI-generated files
  createdBy: text('created_by'), // 'user' or agent name
  lastEditedBy: text('last_edited_by'),
  lastEditedAt: timestamp('last_edited_at', { withTimezone: true, mode: 'string' }),
  // Optimistic locking
  version: integer('version').default(0), // Version number for optimistic locking
  createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => ({
  ownerUserIdIdx: index('idx_files_owner_user_id').on(table.ownerUserId),
  folderIdIdx: index('idx_files_folder_id').on(table.folderId),
  nameIdx: index('idx_files_name').on(table.name),
  pathIdx: index('idx_files_path').on(table.path),
  userPathIdx: index('idx_files_user_path').on(table.ownerUserId, table.path),
  isAIGeneratedIdx: index('idx_files_is_ai_generated').on(table.isAIGenerated),
  indexingStatusIdx: index('idx_files_indexing_status').on(table.indexingStatus),
  createdAtIdx: index('idx_files_created_at').on(table.createdAt),
  // Prevent duplicate names in same folder
  uniqueNameInFolder: unique('files_unique_name_in_folder').on(table.ownerUserId, table.folderId, table.name),
}));

// ============================================================================
// 13. SHADOW_ENTITIES TABLE (Semantic Search Layer)
// ============================================================================

export const shadowEntities = pgTable('shadow_entities', {
  id: uuid('id').primaryKey().defaultRandom(),
  ownerUserId: uuid('owner_user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE

  // Polymorphic entity reference
  entityId: uuid('entity_id').notNull(), // file_id, thread_id, or kg_node_id
  entityType: text('entity_type').notNull(), // 'file' | 'thread' | 'kg_node'

  // Semantic search
  embedding: vector('embedding').notNull(), // 768-dim vector for semantic search
  summary: text('summary').notNull(), // 2-3 sentence AI-generated summary

  // Entity-specific metadata (JSONB for flexibility)
  structureMetadata: jsonb('structure_metadata'),

  // Tracking
  lastUpdated: timestamp('last_updated', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
  createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
}, (table) => ({
  ownerUserIdIdx: index('idx_shadow_entities_owner_user_id').on(table.ownerUserId),
  entityIdx: index('idx_shadow_entities_entity').on(table.entityId, table.entityType),
  createdAtIdx: index('idx_shadow_entities_created_at').on(table.createdAt),
}));

// ============================================================================
// RLS POLICIES (Applied via migration SQL)
// ============================================================================

// These SQL statements will be added to migrations for RLS policies
// Drizzle ORM doesn't have native RLS support, so we define these separately

export const rlsPolicies = {
  userProfiles: `
    -- Enable RLS on user_profiles
    ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;

    -- Users can view own profile
    CREATE POLICY "Users can view own profile"
      ON user_profiles FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can update own profile
    CREATE POLICY "Users can update own profile"
      ON user_profiles FOR UPDATE
      USING (auth.uid() = user_id);
  `,

  folders: `
    -- Enable RLS on folders
    ALTER TABLE folders ENABLE ROW LEVEL SECURITY;

    -- Users can read only their own folders
    CREATE POLICY "Users can read own folders"
      ON folders FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can insert folders into their own hierarchy
    CREATE POLICY "Users can create own folders"
      ON folders FOR INSERT
      WITH CHECK (auth.uid() = user_id);

    -- Users can update their own folders
    CREATE POLICY "Users can update own folders"
      ON folders FOR UPDATE
      USING (auth.uid() = user_id);

    -- Users can delete their own folders (cascade to children via FK)
    CREATE POLICY "Users can delete own folders"
      ON folders FOR DELETE
      USING (auth.uid() = user_id);
  `,

  documents: `
    -- Enable RLS on documents
    ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

    -- Users can view own documents
    CREATE POLICY "Users can view own documents"
      ON documents FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can insert own documents
    CREATE POLICY "Users can insert own documents"
      ON documents FOR INSERT
      WITH CHECK (auth.uid() = user_id);

    -- Users can update own documents
    CREATE POLICY "Users can update own documents"
      ON documents FOR UPDATE
      USING (auth.uid() = user_id);

    -- Users can delete own documents
    CREATE POLICY "Users can delete own documents"
      ON documents FOR DELETE
      USING (auth.uid() = user_id);
  `,

  documentChunks: `
    -- Enable RLS on document_chunks
    ALTER TABLE document_chunks ENABLE ROW LEVEL SECURITY;

    -- Users can view chunks of own documents
    CREATE POLICY "Users can view chunks of own documents"
      ON document_chunks FOR SELECT
      USING (EXISTS (
        SELECT 1 FROM documents
        WHERE documents.id = document_chunks.document_id
        AND documents.user_id = auth.uid()
      ));

    -- Users can insert chunks for own documents
    CREATE POLICY "Users can insert chunks for own documents"
      ON document_chunks FOR INSERT
      WITH CHECK (EXISTS (
        SELECT 1 FROM documents
        WHERE documents.id = document_chunks.document_id
        AND documents.user_id = auth.uid()
      ));

    -- Users can update chunks of own documents
    CREATE POLICY "Users can update chunks of own documents"
      ON document_chunks FOR UPDATE
      USING (EXISTS (
        SELECT 1 FROM documents
        WHERE documents.id = document_chunks.document_id
        AND documents.user_id = auth.uid()
      ));

    -- Users can delete chunks of own documents
    CREATE POLICY "Users can delete chunks of own documents"
      ON document_chunks FOR DELETE
      USING (EXISTS (
        SELECT 1 FROM documents
        WHERE documents.id = document_chunks.document_id
        AND documents.user_id = auth.uid()
      ));
  `,

  agentRequests: `
    -- Enable RLS on agent_requests
    ALTER TABLE agent_requests ENABLE ROW LEVEL SECURITY;

    -- Users can view own requests
    CREATE POLICY "Users can view own agent requests"
      ON agent_requests FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can insert own requests
    CREATE POLICY "Users can insert own agent requests"
      ON agent_requests FOR INSERT
      WITH CHECK (auth.uid() = user_id);

    -- Users can update own requests
    CREATE POLICY "Users can update own agent requests"
      ON agent_requests FOR UPDATE
      USING (auth.uid() = user_id);

    -- Users can delete own requests
    CREATE POLICY "Users can delete own agent requests"
      ON agent_requests FOR DELETE
      USING (auth.uid() = user_id);
  `,

  agentSessions: `
    -- Enable RLS on agent_sessions
    ALTER TABLE agent_sessions ENABLE ROW LEVEL SECURITY;

    -- Users can view own sessions
    CREATE POLICY "Users can view own agent sessions"
      ON agent_sessions FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can insert own sessions
    CREATE POLICY "Users can insert own agent sessions"
      ON agent_sessions FOR INSERT
      WITH CHECK (auth.uid() = user_id);

    -- Users can update own sessions
    CREATE POLICY "Users can update own agent sessions"
      ON agent_sessions FOR UPDATE
      USING (auth.uid() = user_id);

    -- Users can delete own sessions
    CREATE POLICY "Users can delete own agent sessions"
      ON agent_sessions FOR DELETE
      USING (auth.uid() = user_id);
  `,

  usageEvents: `
    -- Enable RLS on usage_events
    ALTER TABLE usage_events ENABLE ROW LEVEL SECURITY;

    -- Users can view own usage events
    CREATE POLICY "Users can view own usage events"
      ON usage_events FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can insert own usage events
    CREATE POLICY "Users can insert own usage events"
      ON usage_events FOR INSERT
      WITH CHECK (auth.uid() = user_id);

    -- No UPDATE or DELETE allowed (immutable audit trail)
  `,

  agentExecutionEvents: `
    -- Enable RLS on agent_execution_events
    ALTER TABLE agent_execution_events ENABLE ROW LEVEL SECURITY;

    -- Users can view events from their own agent requests (via FK to agent_requests)
    CREATE POLICY "Users can view own agent execution events"
      ON agent_execution_events FOR SELECT
      USING (EXISTS (
        SELECT 1 FROM agent_requests
        WHERE agent_requests.id = agent_execution_events.request_id
        AND agent_requests.user_id = auth.uid()
      ));

    -- No INSERT/UPDATE/DELETE - events are server-generated immutable records
  `,

  shadowEntities: `
    -- Enable RLS on shadow_entities
    ALTER TABLE shadow_entities ENABLE ROW LEVEL SECURITY;

    -- Users can view own shadow entities
    CREATE POLICY "Users can view own shadow entities"
      ON shadow_entities FOR SELECT
      USING (auth.uid() = owner_user_id);

    -- Users can insert own shadow entities
    CREATE POLICY "Users can insert own shadow entities"
      ON shadow_entities FOR INSERT
      WITH CHECK (auth.uid() = owner_user_id);

    -- Users can update own shadow entities
    CREATE POLICY "Users can update own shadow entities"
      ON shadow_entities FOR UPDATE
      USING (auth.uid() = owner_user_id);

    -- Users can delete own shadow entities
    CREATE POLICY "Users can delete own shadow entities"
      ON shadow_entities FOR DELETE
      USING (auth.uid() = owner_user_id);
  `,
};

// ============================================================================
// TRIGGERS (Applied via migration SQL)
// ============================================================================

export const triggers = {
  // Automatic updated_at timestamp update
  updateUpdatedAt: `
    CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS $$
    BEGIN
      NEW.updated_at = NOW();
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    -- Apply to all tables with updated_at
    CREATE TRIGGER update_user_profiles_updated_at
      BEFORE UPDATE ON user_profiles
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();

    CREATE TRIGGER update_folders_updated_at
      BEFORE UPDATE ON folders
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();

    CREATE TRIGGER update_documents_updated_at
      BEFORE UPDATE ON documents
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();

    CREATE TRIGGER update_document_chunks_updated_at
      BEFORE UPDATE ON document_chunks
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();

    CREATE TRIGGER update_agent_requests_updated_at
      BEFORE UPDATE ON agent_requests
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();

    CREATE TRIGGER update_agent_sessions_updated_at
      BEFORE UPDATE ON agent_sessions
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();
  `,

  // Auto-create user profile on auth.users insert
  // NOTE: For MVP account foundation, Edge Function handles profile creation explicitly
  // with atomic rollback logic (research.md). This trigger is DISABLED to avoid conflicts.
  // Re-enable post-MVP if Edge Function approach is replaced.
  autoCreateProfile: `
    -- DISABLED: Edge Function handles profile creation with rollback
    -- CREATE OR REPLACE FUNCTION create_user_profile()
    -- RETURNS TRIGGER AS $$
    -- BEGIN
    --   INSERT INTO user_profiles (user_id, first_name, last_name)
    --   VALUES (
    --     NEW.id,
    --     NEW.raw_user_meta_data->>'first_name',
    --     NEW.raw_user_meta_data->>'last_name'
    --   );
    --   RETURN NEW;
    -- END;
    -- $$ LANGUAGE plpgsql;

    -- CREATE TRIGGER on_auth_user_created
    --   AFTER INSERT ON auth.users
    --   FOR EACH ROW
    --   EXECUTE FUNCTION create_user_profile();
  `,

  // Full-text search vector generation
  // NOTE: tsvector columns defined in schema using customType
  // Triggers and indexes applied via this SQL
  searchVectors: `
    -- Create GIN indexes for full-text search performance
    CREATE INDEX IF NOT EXISTS documents_search_vector_idx
      ON documents USING GIN (search_vector);

    CREATE INDEX IF NOT EXISTS document_chunks_search_vector_idx
      ON document_chunks USING GIN (search_vector);

    -- Create triggers to auto-update search vectors on INSERT/UPDATE
    DROP TRIGGER IF EXISTS update_documents_search_vector ON documents;
    CREATE TRIGGER update_documents_search_vector
      BEFORE INSERT OR UPDATE OF content_text ON documents
      FOR EACH ROW
      EXECUTE FUNCTION tsvector_update_trigger(search_vector, 'pg_catalog.english', content_text);

    DROP TRIGGER IF EXISTS update_chunks_search_vector ON document_chunks;
    CREATE TRIGGER update_chunks_search_vector
      BEFORE INSERT OR UPDATE OF content ON document_chunks
      FOR EACH ROW
      EXECUTE FUNCTION tsvector_update_trigger(search_vector, 'pg_catalog.english', content);
  `,
};

// ============================================================================
// CASCADE DELETE FOREIGN KEYS
// ============================================================================
// These foreign keys to auth.users must be added separately since auth schema
// is not managed by Drizzle. Apply this SQL after pushing schema with drizzle-kit.
// Usage: Run cascadeDeleteSQL via database client or Supabase Dashboard SQL Editor

export const cascadeDeleteSQL = `
-- Add CASCADE DELETE foreign keys for GDPR compliance

-- User Profiles
ALTER TABLE user_profiles
  DROP CONSTRAINT IF EXISTS user_profiles_user_id_fkey;
ALTER TABLE user_profiles
  ADD CONSTRAINT user_profiles_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Folders (user ownership + self-referential hierarchy)
ALTER TABLE folders
  DROP CONSTRAINT IF EXISTS folders_user_id_fkey;
ALTER TABLE folders
  ADD CONSTRAINT folders_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

ALTER TABLE folders
  DROP CONSTRAINT IF EXISTS folders_parent_folder_id_fkey;
ALTER TABLE folders
  ADD CONSTRAINT folders_parent_folder_id_fkey
  FOREIGN KEY (parent_folder_id) REFERENCES folders(id) ON DELETE CASCADE;

-- Threads (self-referential hierarchy for branches)
ALTER TABLE threads
  DROP CONSTRAINT IF EXISTS threads_parent_thread_id_fkey;
ALTER TABLE threads
  ADD CONSTRAINT threads_parent_thread_id_fkey
  FOREIGN KEY (parent_thread_id) REFERENCES threads(id) ON DELETE CASCADE;

-- Documents (user ownership + folder hierarchy)
ALTER TABLE documents
  DROP CONSTRAINT IF EXISTS documents_user_id_fkey;
ALTER TABLE documents
  ADD CONSTRAINT documents_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

ALTER TABLE documents
  DROP CONSTRAINT IF EXISTS documents_folder_id_fkey;
ALTER TABLE documents
  ADD CONSTRAINT documents_folder_id_fkey
  FOREIGN KEY (folder_id) REFERENCES folders(id) ON DELETE CASCADE;

-- Document Chunks (cascade from documents)
ALTER TABLE document_chunks
  DROP CONSTRAINT IF EXISTS document_chunks_document_id_fkey;
ALTER TABLE document_chunks
  ADD CONSTRAINT document_chunks_document_id_fkey
  FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE;

-- Agent Requests
ALTER TABLE agent_requests
  DROP CONSTRAINT IF EXISTS agent_requests_user_id_fkey;
ALTER TABLE agent_requests
  ADD CONSTRAINT agent_requests_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Agent Requests - Thread FK (NEW)
ALTER TABLE agent_requests
  DROP CONSTRAINT IF EXISTS agent_requests_thread_id_fkey;
ALTER TABLE agent_requests
  ADD CONSTRAINT agent_requests_thread_id_fkey
  FOREIGN KEY (thread_id) REFERENCES threads(id) ON DELETE CASCADE;

-- Agent Requests - Triggering Message FK (NEW)
ALTER TABLE agent_requests
  DROP CONSTRAINT IF EXISTS agent_requests_triggering_message_id_fkey;
ALTER TABLE agent_requests
  ADD CONSTRAINT agent_requests_triggering_message_id_fkey
  FOREIGN KEY (triggering_message_id) REFERENCES messages(id) ON DELETE CASCADE;

-- Agent Requests - Response Message FK (NEW, optional)
ALTER TABLE agent_requests
  DROP CONSTRAINT IF EXISTS agent_requests_response_message_id_fkey;
ALTER TABLE agent_requests
  ADD CONSTRAINT agent_requests_response_message_id_fkey
  FOREIGN KEY (response_message_id) REFERENCES messages(id) ON DELETE SET NULL;

-- Agent Tool Calls - Agent Request FK (NEW)
ALTER TABLE agent_tool_calls
  DROP CONSTRAINT IF EXISTS agent_tool_calls_request_id_fkey;
ALTER TABLE agent_tool_calls
  ADD CONSTRAINT agent_tool_calls_request_id_fkey
  FOREIGN KEY (request_id) REFERENCES agent_requests(id) ON DELETE CASCADE;

-- Messages - Agent Request FK (for requestId field)
ALTER TABLE messages
  DROP CONSTRAINT IF EXISTS messages_request_id_fkey;
ALTER TABLE messages
  ADD CONSTRAINT messages_request_id_fkey
  FOREIGN KEY (request_id) REFERENCES agent_requests(id) ON DELETE SET NULL;

-- Agent Sessions
ALTER TABLE agent_sessions
  DROP CONSTRAINT IF EXISTS agent_sessions_user_id_fkey;
ALTER TABLE agent_sessions
  ADD CONSTRAINT agent_sessions_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Usage Events
ALTER TABLE usage_events
  DROP CONSTRAINT IF EXISTS usage_events_user_id_fkey;
ALTER TABLE usage_events
  ADD CONSTRAINT usage_events_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Shadow Entities
ALTER TABLE shadow_entities
  DROP CONSTRAINT IF EXISTS shadow_entities_owner_user_id_fkey;
ALTER TABLE shadow_entities
  ADD CONSTRAINT shadow_entities_owner_user_id_fkey
  FOREIGN KEY (owner_user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Verify CASCADE constraints
SELECT
  conname AS constraint_name,
  conrelid::regclass AS table_name,
  confrelid::regclass AS references_table
FROM pg_constraint
WHERE confdeltype = 'c'  -- 'c' = CASCADE
ORDER BY conname;
`;

// ============================================================================
// PGVECTOR EXTENSION (Vector Embeddings for RAG)
// ============================================================================
// Enable pgvector extension and add embedding column to document_chunks
// Must be run after initial schema push

export const pgvectorSQL = `
-- Enable pgvector extension for vector similarity search
CREATE EXTENSION IF NOT EXISTS vector;

-- Add embedding column to document_chunks table
ALTER TABLE document_chunks
ADD COLUMN IF NOT EXISTS embedding vector(1536);

-- Create HNSW index for fast vector similarity search
CREATE INDEX IF NOT EXISTS document_chunks_embedding_idx
ON document_chunks
USING hnsw (embedding vector_cosine_ops);
`;

// ============================================================================
// REALTIME PUBLICATION
// ============================================================================
// Enable realtime for tables that need real-time subscriptions
// Must be run after schema push

export const realtimePublicationSQL = `
-- Enable realtime for all tables (for streaming updates)
-- Uses SET TABLE instead of ADD TABLE for idempotency
ALTER PUBLICATION supabase_realtime SET TABLE
  agent_requests,
  agent_execution_events,
  agent_sessions,
  documents,
  document_chunks,
  folders,
  threads,
  messages,
  context_references,
  files,
  shadow_entities,
  user_profiles;

-- CRITICAL: Set REPLICA IDENTITY to FULL for DELETE events
-- Default behavior: DELETE events only include primary key (id)
-- FULL behavior: DELETE events include all columns (including user_id)
-- Why needed: Subscription filters need user_id and other columns for authorization
ALTER TABLE agent_requests REPLICA IDENTITY FULL;
ALTER TABLE agent_execution_events REPLICA IDENTITY FULL;
ALTER TABLE agent_sessions REPLICA IDENTITY FULL;
ALTER TABLE documents REPLICA IDENTITY FULL;
ALTER TABLE document_chunks REPLICA IDENTITY FULL;
ALTER TABLE folders REPLICA IDENTITY FULL;
ALTER TABLE threads REPLICA IDENTITY FULL;
ALTER TABLE messages REPLICA IDENTITY FULL;
ALTER TABLE context_references REPLICA IDENTITY FULL;
ALTER TABLE files REPLICA IDENTITY FULL;
ALTER TABLE shadow_entities REPLICA IDENTITY FULL;
ALTER TABLE user_profiles REPLICA IDENTITY FULL;
`;
