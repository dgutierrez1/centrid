import { pgTable, uuid, text, integer, timestamp, real, jsonb, index, unique } from 'drizzle-orm/pg-core';

/**
 * Database Schema for Centrid MVP
 *
 * 6 core tables:
 * - user_profiles: Extended user data beyond auth.users
 * - documents: File metadata with full-text search
 * - document_chunks: RAG text segments
 * - agent_requests: AI agent execution tracking
 * - agent_sessions: Multi-turn conversation management
 * - usage_events: Usage tracking for billing
 */

// ============================================================================
// 1. USER_PROFILES TABLE
// ============================================================================

export const userProfiles = pgTable('user_profiles', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull().unique(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  firstName: text('first_name').notNull(), // Required: user must provide during signup for personalization
  lastName: text('last_name').notNull(), // Required: user must provide during signup for personalization
  planType: text('plan_type').notNull().default('free'),
  usageCount: integer('usage_count').notNull().default(0),
  subscriptionStatus: text('subscription_status').notNull().default('active'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('user_profiles_user_id_idx').on(table.userId),
}));

// ============================================================================
// 2. DOCUMENTS TABLE
// ============================================================================

export const documents = pgTable('documents', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  filename: text('filename').notNull(),
  fileType: text('file_type').notNull(),
  fileSize: integer('file_size').notNull(),
  processingStatus: text('processing_status').notNull().default('pending'),
  contentText: text('content_text'),
  // searchVector will be auto-generated by trigger
  searchVector: text('search_vector'),
  storagePath: text('storage_path'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('documents_user_id_idx').on(table.userId),
  processingStatusIdx: index('documents_processing_status_idx').on(table.processingStatus),
  createdAtIdx: index('documents_created_at_idx').on(table.createdAt),
}));

// ============================================================================
// 3. DOCUMENT_CHUNKS TABLE
// ============================================================================

export const documentChunks = pgTable('document_chunks', {
  id: uuid('id').primaryKey().defaultRandom(),
  documentId: uuid('document_id').notNull(), // FK to documents(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  chunkIndex: integer('chunk_index').notNull(),
  content: text('content').notNull(),
  sectionTitle: text('section_title'),
  // searchVector will be auto-generated by trigger
  searchVector: text('search_vector'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  documentIdIdx: index('document_chunks_document_id_idx').on(table.documentId),
  uniqueChunk: unique('document_chunks_document_id_chunk_index_unique').on(table.documentId, table.chunkIndex),
}));

// ============================================================================
// 4. AGENT_REQUESTS TABLE
// ============================================================================

export const agentRequests = pgTable('agent_requests', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  agentType: text('agent_type').notNull(),
  content: text('content').notNull(),
  status: text('status').notNull().default('pending'),
  progress: real('progress').notNull().default(0),
  results: jsonb('results'),
  tokenCost: integer('token_cost'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('agent_requests_user_id_idx').on(table.userId),
  statusIdx: index('agent_requests_status_idx').on(table.status),
  createdAtIdx: index('agent_requests_created_at_idx').on(table.createdAt),
}));

// ============================================================================
// 5. AGENT_SESSIONS TABLE
// ============================================================================

export const agentSessions = pgTable('agent_sessions', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  requestChain: jsonb('request_chain').notNull().default([]),
  contextState: jsonb('context_state'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('agent_sessions_user_id_idx').on(table.userId),
  updatedAtIdx: index('agent_sessions_updated_at_idx').on(table.updatedAt),
}));

// ============================================================================
// 6. USAGE_EVENTS TABLE
// ============================================================================

export const usageEvents = pgTable('usage_events', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
  eventType: text('event_type').notNull(),
  tokensUsed: integer('tokens_used'),
  cost: real('cost'),
  metadata: jsonb('metadata'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  userIdIdx: index('usage_events_user_id_idx').on(table.userId),
  createdAtIdx: index('usage_events_created_at_idx').on(table.createdAt),
  eventTypeIdx: index('usage_events_event_type_idx').on(table.eventType),
}));

// ============================================================================
// RLS POLICIES (Applied via migration SQL)
// ============================================================================

// These SQL statements will be added to migrations for RLS policies
// Drizzle ORM doesn't have native RLS support, so we define these separately

export const rlsPolicies = {
  userProfiles: `
    -- Enable RLS on user_profiles
    ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;

    -- Users can view own profile
    CREATE POLICY "Users can view own profile"
      ON user_profiles FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can update own profile
    CREATE POLICY "Users can update own profile"
      ON user_profiles FOR UPDATE
      USING (auth.uid() = user_id);
  `,

  documents: `
    -- Enable RLS on documents
    ALTER TABLE documents ENABLE ROW LEVEL SECURITY;

    -- Users can view own documents
    CREATE POLICY "Users can view own documents"
      ON documents FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can insert own documents
    CREATE POLICY "Users can insert own documents"
      ON documents FOR INSERT
      WITH CHECK (auth.uid() = user_id);

    -- Users can update own documents
    CREATE POLICY "Users can update own documents"
      ON documents FOR UPDATE
      USING (auth.uid() = user_id);

    -- Users can delete own documents
    CREATE POLICY "Users can delete own documents"
      ON documents FOR DELETE
      USING (auth.uid() = user_id);
  `,

  documentChunks: `
    -- Enable RLS on document_chunks
    ALTER TABLE document_chunks ENABLE ROW LEVEL SECURITY;

    -- Users can view chunks of own documents
    CREATE POLICY "Users can view chunks of own documents"
      ON document_chunks FOR SELECT
      USING (EXISTS (
        SELECT 1 FROM documents
        WHERE documents.id = document_chunks.document_id
        AND documents.user_id = auth.uid()
      ));

    -- Users can insert chunks for own documents
    CREATE POLICY "Users can insert chunks for own documents"
      ON document_chunks FOR INSERT
      WITH CHECK (EXISTS (
        SELECT 1 FROM documents
        WHERE documents.id = document_chunks.document_id
        AND documents.user_id = auth.uid()
      ));

    -- Users can update chunks of own documents
    CREATE POLICY "Users can update chunks of own documents"
      ON document_chunks FOR UPDATE
      USING (EXISTS (
        SELECT 1 FROM documents
        WHERE documents.id = document_chunks.document_id
        AND documents.user_id = auth.uid()
      ));

    -- Users can delete chunks of own documents
    CREATE POLICY "Users can delete chunks of own documents"
      ON document_chunks FOR DELETE
      USING (EXISTS (
        SELECT 1 FROM documents
        WHERE documents.id = document_chunks.document_id
        AND documents.user_id = auth.uid()
      ));
  `,

  agentRequests: `
    -- Enable RLS on agent_requests
    ALTER TABLE agent_requests ENABLE ROW LEVEL SECURITY;

    -- Users can view own requests
    CREATE POLICY "Users can view own agent requests"
      ON agent_requests FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can insert own requests
    CREATE POLICY "Users can insert own agent requests"
      ON agent_requests FOR INSERT
      WITH CHECK (auth.uid() = user_id);

    -- Users can update own requests
    CREATE POLICY "Users can update own agent requests"
      ON agent_requests FOR UPDATE
      USING (auth.uid() = user_id);

    -- Users can delete own requests
    CREATE POLICY "Users can delete own agent requests"
      ON agent_requests FOR DELETE
      USING (auth.uid() = user_id);
  `,

  agentSessions: `
    -- Enable RLS on agent_sessions
    ALTER TABLE agent_sessions ENABLE ROW LEVEL SECURITY;

    -- Users can view own sessions
    CREATE POLICY "Users can view own agent sessions"
      ON agent_sessions FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can insert own sessions
    CREATE POLICY "Users can insert own agent sessions"
      ON agent_sessions FOR INSERT
      WITH CHECK (auth.uid() = user_id);

    -- Users can update own sessions
    CREATE POLICY "Users can update own agent sessions"
      ON agent_sessions FOR UPDATE
      USING (auth.uid() = user_id);

    -- Users can delete own sessions
    CREATE POLICY "Users can delete own agent sessions"
      ON agent_sessions FOR DELETE
      USING (auth.uid() = user_id);
  `,

  usageEvents: `
    -- Enable RLS on usage_events
    ALTER TABLE usage_events ENABLE ROW LEVEL SECURITY;

    -- Users can view own usage events
    CREATE POLICY "Users can view own usage events"
      ON usage_events FOR SELECT
      USING (auth.uid() = user_id);

    -- Users can insert own usage events
    CREATE POLICY "Users can insert own usage events"
      ON usage_events FOR INSERT
      WITH CHECK (auth.uid() = user_id);

    -- No UPDATE or DELETE allowed (immutable audit trail)
  `,
};

// ============================================================================
// TRIGGERS (Applied via migration SQL)
// ============================================================================

export const triggers = {
  // Automatic updated_at timestamp update
  updateUpdatedAt: `
    CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS $$
    BEGIN
      NEW.updated_at = NOW();
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    -- Apply to all tables with updated_at
    CREATE TRIGGER update_user_profiles_updated_at
      BEFORE UPDATE ON user_profiles
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();

    CREATE TRIGGER update_documents_updated_at
      BEFORE UPDATE ON documents
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();

    CREATE TRIGGER update_agent_requests_updated_at
      BEFORE UPDATE ON agent_requests
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();

    CREATE TRIGGER update_agent_sessions_updated_at
      BEFORE UPDATE ON agent_sessions
      FOR EACH ROW
      EXECUTE FUNCTION update_updated_at_column();
  `,

  // Auto-create user profile on auth.users insert
  // NOTE: For MVP account foundation, Edge Function handles profile creation explicitly
  // with atomic rollback logic (research.md). This trigger is DISABLED to avoid conflicts.
  // Re-enable post-MVP if Edge Function approach is replaced.
  autoCreateProfile: `
    -- DISABLED: Edge Function handles profile creation with rollback
    -- CREATE OR REPLACE FUNCTION create_user_profile()
    -- RETURNS TRIGGER AS $$
    -- BEGIN
    --   INSERT INTO user_profiles (user_id, first_name, last_name)
    --   VALUES (
    --     NEW.id,
    --     NEW.raw_user_meta_data->>'first_name',
    --     NEW.raw_user_meta_data->>'last_name'
    --   );
    --   RETURN NEW;
    -- END;
    -- $$ LANGUAGE plpgsql;

    -- CREATE TRIGGER on_auth_user_created
    --   AFTER INSERT ON auth.users
    --   FOR EACH ROW
    --   EXECUTE FUNCTION create_user_profile();
  `,

  // Full-text search vector generation (requires tsvector type)
  // NOTE: Drizzle doesn't support tsvector natively yet
  // This will be handled in a custom migration
  searchVectors: `
    -- Add tsvector columns if not exists (handled by Drizzle schema)
    -- ALTER TABLE documents ADD COLUMN IF NOT EXISTS search_vector tsvector;
    -- ALTER TABLE document_chunks ADD COLUMN IF NOT EXISTS search_vector tsvector;

    -- Create GIN indexes for full-text search
    CREATE INDEX IF NOT EXISTS documents_search_vector_idx ON documents USING GIN (to_tsvector('english', COALESCE(content_text, '')));
    CREATE INDEX IF NOT EXISTS document_chunks_search_vector_idx ON document_chunks USING GIN (to_tsvector('english', content));

    -- Create triggers to auto-update search vectors
    CREATE TRIGGER update_documents_search_vector
      BEFORE INSERT OR UPDATE OF content_text ON documents
      FOR EACH ROW
      EXECUTE FUNCTION tsvector_update_trigger(search_vector, 'pg_catalog.english', content_text);

    CREATE TRIGGER update_chunks_search_vector
      BEFORE INSERT OR UPDATE OF content ON document_chunks
      FOR EACH ROW
      EXECUTE FUNCTION tsvector_update_trigger(search_vector, 'pg_catalog.english', content);
  `,
};

// ============================================================================
// CASCADE DELETE FOREIGN KEYS
// ============================================================================
// These foreign keys to auth.users must be added separately since auth schema
// is not managed by Drizzle. Apply this SQL after pushing schema with drizzle-kit.
// Usage: Run cascadeDeleteSQL via database client or Supabase Dashboard SQL Editor

export const cascadeDeleteSQL = `
-- Add CASCADE DELETE foreign keys for GDPR compliance

-- User Profiles
ALTER TABLE user_profiles
  DROP CONSTRAINT IF EXISTS user_profiles_user_id_fkey;
ALTER TABLE user_profiles
  ADD CONSTRAINT user_profiles_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Documents
ALTER TABLE documents
  DROP CONSTRAINT IF EXISTS documents_user_id_fkey;
ALTER TABLE documents
  ADD CONSTRAINT documents_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Document Chunks (cascade from documents)
ALTER TABLE document_chunks
  DROP CONSTRAINT IF EXISTS document_chunks_document_id_fkey;
ALTER TABLE document_chunks
  ADD CONSTRAINT document_chunks_document_id_fkey
  FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE;

-- Agent Requests
ALTER TABLE agent_requests
  DROP CONSTRAINT IF EXISTS agent_requests_user_id_fkey;
ALTER TABLE agent_requests
  ADD CONSTRAINT agent_requests_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Agent Sessions
ALTER TABLE agent_sessions
  DROP CONSTRAINT IF EXISTS agent_sessions_user_id_fkey;
ALTER TABLE agent_sessions
  ADD CONSTRAINT agent_sessions_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Usage Events
ALTER TABLE usage_events
  DROP CONSTRAINT IF EXISTS usage_events_user_id_fkey;
ALTER TABLE usage_events
  ADD CONSTRAINT usage_events_user_id_fkey
  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Verify CASCADE constraints
SELECT
  conname AS constraint_name,
  conrelid::regclass AS table_name,
  confrelid::regclass AS references_table
FROM pg_constraint
WHERE confdeltype = 'c'  -- 'c' = CASCADE
ORDER BY conname;
`;
