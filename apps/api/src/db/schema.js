"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.realtimePublicationSQL = exports.pgvectorSQL = exports.cascadeDeleteSQL = exports.triggers = exports.rlsPolicies = exports.files = exports.contextReferences = exports.agentToolCalls = exports.messages = exports.threads = exports.usageEvents = exports.agentSessions = exports.agentExecutionEvents = exports.agentRequests = exports.documentChunks = exports.documents = exports.folders = exports.userProfiles = void 0;
var pg_core_1 = require("drizzle-orm/pg-core");
/**
 * Database Schema for Centrid MVP
 *
 * 7 core tables:
 * - user_profiles: Extended user data beyond auth.users
 * - folders: Hierarchical folder structure for documents
 * - documents: File metadata with full-text search
 * - document_chunks: RAG text segments
 * - agent_requests: AI agent execution tracking
 * - agent_sessions: Multi-turn conversation management
 * - usage_events: Usage tracking for billing
 */
// Custom tsvector type for full-text search
var tsvector = (0, pg_core_1.customType)({
    dataType: function () {
        return 'tsvector';
    },
});
// ============================================================================
// 1. USER_PROFILES TABLE
// ============================================================================
exports.userProfiles = (0, pg_core_1.pgTable)('user_profiles', {
    id: (0, pg_core_1.uuid)('id').primaryKey().defaultRandom(),
    userId: (0, pg_core_1.uuid)('user_id').notNull().unique(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
    firstName: (0, pg_core_1.text)('first_name').notNull(), // Required: user must provide during signup for personalization
    lastName: (0, pg_core_1.text)('last_name').notNull(), // Required: user must provide during signup for personalization
    planType: (0, pg_core_1.text)('plan_type').notNull().default('free'),
    usageCount: (0, pg_core_1.integer)('usage_count').notNull().default(0),
    subscriptionStatus: (0, pg_core_1.text)('subscription_status').notNull().default('active'),
    createdAt: (0, pg_core_1.timestamp)('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: (0, pg_core_1.timestamp)('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, function (table) { return ({
    userIdIdx: (0, pg_core_1.index)('user_profiles_user_id_idx').on(table.userId),
}); });
// ============================================================================
// 2. FOLDERS TABLE
// ============================================================================
exports.folders = (0, pg_core_1.pgTable)('folders', {
    id: (0, pg_core_1.uuid)('id').primaryKey().defaultRandom(),
    userId: (0, pg_core_1.uuid)('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE
    name: (0, pg_core_1.text)('name').notNull(),
    parentFolderId: (0, pg_core_1.uuid)('parent_folder_id'), // Self-referential FK, null = root
    path: (0, pg_core_1.text)('path').notNull(), // Computed path from hierarchy
    createdAt: (0, pg_core_1.timestamp)('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: (0, pg_core_1.timestamp)('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, function (table) { return ({
    userIdIdx: (0, pg_core_1.index)('folders_user_id_idx').on(table.userId),
    parentFolderIdIdx: (0, pg_core_1.index)('folders_parent_folder_id_idx').on(table.parentFolderId),
    uniqueNameInParent: (0, pg_core_1.unique)('folders_unique_name_in_parent').on(table.userId, table.parentFolderId, table.name),
}); });
// ============================================================================
// 3. DOCUMENTS TABLE
// ============================================================================
exports.documents = (0, pg_core_1.pgTable)('documents', {
    id: (0, pg_core_1.uuid)('id').primaryKey().defaultRandom(),
    userId: (0, pg_core_1.uuid)('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
    folderId: (0, pg_core_1.uuid)('folder_id'), // FK to folders(id) ON DELETE CASCADE, null = root level
    name: (0, pg_core_1.text)('name').notNull(), // Filename with extension
    storagePath: (0, pg_core_1.text)('storage_path').notNull(), // Path in Supabase Storage
    contentText: (0, pg_core_1.text)('content_text'), // Cached markdown content for fast access
    fileSize: (0, pg_core_1.integer)('file_size').notNull(),
    mimeType: (0, pg_core_1.text)('mime_type').notNull(), // 'text/markdown' or 'text/plain'
    path: (0, pg_core_1.text)('path').notNull(), // Computed path for breadcrumbs
    version: (0, pg_core_1.integer)('version').notNull().default(0), // Optimistic locking
    indexingStatus: (0, pg_core_1.text)('indexing_status').notNull().default('pending'), // 'pending', 'in_progress', 'completed', 'failed'
    // searchVector auto-generated by trigger (see triggers.searchVectors below)
    searchVector: tsvector('search_vector'),
    createdAt: (0, pg_core_1.timestamp)('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: (0, pg_core_1.timestamp)('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, function (table) { return ({
    userIdIdx: (0, pg_core_1.index)('documents_user_id_idx').on(table.userId),
    folderIdIdx: (0, pg_core_1.index)('documents_folder_id_idx').on(table.folderId),
    indexingStatusIdx: (0, pg_core_1.index)('documents_indexing_status_idx').on(table.indexingStatus),
    uniqueNameInFolder: (0, pg_core_1.unique)('documents_unique_name_in_folder').on(table.userId, table.folderId, table.name),
    createdAtIdx: (0, pg_core_1.index)('documents_created_at_idx').on(table.createdAt),
}); });
// ============================================================================
// 4. DOCUMENT_CHUNKS TABLE
// ============================================================================
exports.documentChunks = (0, pg_core_1.pgTable)('document_chunks', {
    id: (0, pg_core_1.uuid)('id').primaryKey().defaultRandom(),
    documentId: (0, pg_core_1.uuid)('document_id').notNull(), // FK to documents(id) ON DELETE CASCADE - see cascadeDeleteSQL below
    content: (0, pg_core_1.text)('content').notNull(), // Markdown text (400-500 tokens)
    position: (0, pg_core_1.integer)('position').notNull(), // Order in original document (0, 1, 2, ...)
    // searchVector auto-generated by trigger (see triggers.searchVectors below)
    searchVector: tsvector('search_vector'),
    // embedding will be added via custom SQL (pgvector extension required)
    // embedding: vector('embedding', { dimensions: 1536 }), // OpenAI text-embedding-3-small
    createdAt: (0, pg_core_1.timestamp)('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: (0, pg_core_1.timestamp)('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, function (table) { return ({
    documentIdIdx: (0, pg_core_1.index)('document_chunks_document_id_idx').on(table.documentId),
    positionIdx: (0, pg_core_1.index)('document_chunks_position_idx').on(table.documentId, table.position),
    uniquePosition: (0, pg_core_1.unique)('document_chunks_document_id_position_unique').on(table.documentId, table.position),
}); });
// ============================================================================
// 5. AGENT_REQUESTS TABLE
// ============================================================================
exports.agentRequests = (0, pg_core_1.pgTable)('agent_requests', {
    id: (0, pg_core_1.uuid)('id').primaryKey().defaultRandom(),
    userId: (0, pg_core_1.uuid)('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
    threadId: (0, pg_core_1.uuid)('thread_id').notNull(), // NEW: Link to thread
    triggeringMessageId: (0, pg_core_1.uuid)('triggering_message_id').notNull(), // NEW: Which user message triggered this request
    responseMessageId: (0, pg_core_1.uuid)('response_message_id'), // NEW: Assistant response message (set at stream end)
    agentType: (0, pg_core_1.text)('agent_type').notNull(),
    content: (0, pg_core_1.text)('content').notNull(),
    status: (0, pg_core_1.text)('status').notNull().default('pending'),
    progress: (0, pg_core_1.real)('progress').notNull().default(0),
    results: (0, pg_core_1.jsonb)('results'),
    checkpoint: (0, pg_core_1.jsonb)('checkpoint'), // NEW: Checkpoint for tool approval suspend/resume
    tokenCost: (0, pg_core_1.integer)('token_cost'), // Keep existing
    createdAt: (0, pg_core_1.timestamp)('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: (0, pg_core_1.timestamp)('updated_at', { withTimezone: true }).defaultNow().notNull(),
    completedAt: (0, pg_core_1.timestamp)('completed_at', { withTimezone: true }), // NEW: When request finished
}, function (table) { return ({
    userIdIdx: (0, pg_core_1.index)('agent_requests_user_id_idx').on(table.userId),
    threadIdIdx: (0, pg_core_1.index)('agent_requests_thread_id_idx').on(table.threadId), // NEW
    triggeringMessageIdx: (0, pg_core_1.index)('agent_requests_triggering_message_idx').on(table.triggeringMessageId), // NEW
    statusIdx: (0, pg_core_1.index)('agent_requests_status_idx').on(table.status),
    createdAtIdx: (0, pg_core_1.index)('agent_requests_created_at_idx').on(table.createdAt),
}); });
// ============================================================================
// 5.5 AGENT_EXECUTION_EVENTS TABLE - Real-time Event Streaming
// ============================================================================
exports.agentExecutionEvents = (0, pg_core_1.pgTable)('agent_execution_events', {
    id: (0, pg_core_1.uuid)('id').primaryKey().defaultRandom(),
    requestId: (0, pg_core_1.uuid)('request_id').notNull(), // FK to agent_requests(id) ON DELETE CASCADE
    type: (0, pg_core_1.text)('type').notNull(), // 'text_chunk', 'tool_call', 'completion', 'error'
    data: (0, pg_core_1.jsonb)('data').notNull(), // Event payload
    createdAt: (0, pg_core_1.timestamp)('created_at', { withTimezone: true }).defaultNow().notNull(),
}, function (table) { return ({
    requestIdIdx: (0, pg_core_1.index)('agent_execution_events_request_id_idx').on(table.requestId),
    requestIdCreatedAtIdx: (0, pg_core_1.index)('agent_execution_events_request_id_created_at_idx').on(table.requestId, table.createdAt),
    typeIdx: (0, pg_core_1.index)('agent_execution_events_type_idx').on(table.type),
}); });
// ============================================================================
// 6. AGENT_SESSIONS TABLE
// ============================================================================
exports.agentSessions = (0, pg_core_1.pgTable)('agent_sessions', {
    id: (0, pg_core_1.uuid)('id').primaryKey().defaultRandom(),
    userId: (0, pg_core_1.uuid)('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
    requestChain: (0, pg_core_1.jsonb)('request_chain').notNull().default([]),
    contextState: (0, pg_core_1.jsonb)('context_state'),
    createdAt: (0, pg_core_1.timestamp)('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: (0, pg_core_1.timestamp)('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, function (table) { return ({
    userIdIdx: (0, pg_core_1.index)('agent_sessions_user_id_idx').on(table.userId),
    updatedAtIdx: (0, pg_core_1.index)('agent_sessions_updated_at_idx').on(table.updatedAt),
}); });
// ============================================================================
// 7. USAGE_EVENTS TABLE
// ============================================================================
exports.usageEvents = (0, pg_core_1.pgTable)('usage_events', {
    id: (0, pg_core_1.uuid)('id').primaryKey().defaultRandom(),
    userId: (0, pg_core_1.uuid)('user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE - see cascadeDeleteSQL below
    eventType: (0, pg_core_1.text)('event_type').notNull(),
    tokensUsed: (0, pg_core_1.integer)('tokens_used'),
    cost: (0, pg_core_1.real)('cost'),
    metadata: (0, pg_core_1.jsonb)('metadata'),
    createdAt: (0, pg_core_1.timestamp)('created_at', { withTimezone: true }).defaultNow().notNull(),
}, function (table) { return ({
    userIdIdx: (0, pg_core_1.index)('usage_events_user_id_idx').on(table.userId),
    createdAtIdx: (0, pg_core_1.index)('usage_events_created_at_idx').on(table.createdAt),
    eventTypeIdx: (0, pg_core_1.index)('usage_events_event_type_idx').on(table.eventType),
}); });
// ============================================================================
// 8. THREADS TABLE (Agent System)
// ============================================================================
exports.threads = (0, pg_core_1.pgTable)('threads', {
    id: (0, pg_core_1.uuid)('id').primaryKey().defaultRandom(),
    ownerUserId: (0, pg_core_1.uuid)('owner_user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE
    parentThreadId: (0, pg_core_1.uuid)('parent_thread_id'), // Self-referential for branches
    branchTitle: (0, pg_core_1.text)('branch_title'), // Title for branch threads
    creator: (0, pg_core_1.text)('creator').notNull(), // 'user' or 'agent'
    createdAt: (0, pg_core_1.timestamp)('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: (0, pg_core_1.timestamp)('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, function (table) { return ({
    ownerUserIdIdx: (0, pg_core_1.index)('idx_threads_owner_user_id').on(table.ownerUserId),
    parentThreadIdIdx: (0, pg_core_1.index)('idx_threads_parent_thread_id').on(table.parentThreadId),
    createdAtIdx: (0, pg_core_1.index)('idx_threads_created_at').on(table.createdAt),
}); });
// ============================================================================
// 9. MESSAGES TABLE (Agent System)
// ============================================================================
exports.messages = (0, pg_core_1.pgTable)('messages', {
    id: (0, pg_core_1.uuid)('id').primaryKey().defaultRandom(),
    threadId: (0, pg_core_1.uuid)('thread_id').notNull(), // FK to threads(id) ON DELETE CASCADE
    ownerUserId: (0, pg_core_1.uuid)('owner_user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE
    role: (0, pg_core_1.text)('role').notNull(), // 'user' or 'assistant'
    content: (0, pg_core_1.text)('content').notNull(),
    toolCalls: (0, pg_core_1.jsonb)('tool_calls').default([]),
    tokensUsed: (0, pg_core_1.integer)('tokens_used').default(0),
    timestamp: (0, pg_core_1.timestamp)('timestamp', { withTimezone: true }).defaultNow().notNull(),
}, function (table) { return ({
    threadIdIdx: (0, pg_core_1.index)('idx_messages_thread_id').on(table.threadId),
    threadTimestampIdx: (0, pg_core_1.index)('idx_messages_thread_id_timestamp').on(table.threadId, table.timestamp),
    ownerUserIdIdx: (0, pg_core_1.index)('idx_messages_owner_user_id').on(table.ownerUserId),
    createdAtIdx: (0, pg_core_1.index)('idx_messages_created_at').on(table.timestamp),
}); });
// ============================================================================
// 10. AGENT_TOOL_CALLS TABLE (Agent System)
// ============================================================================
exports.agentToolCalls = (0, pg_core_1.pgTable)('agent_tool_calls', {
    id: (0, pg_core_1.uuid)('id').primaryKey().defaultRandom(),
    messageId: (0, pg_core_1.uuid)('message_id').notNull(), // FK to messages(id) ON DELETE CASCADE
    threadId: (0, pg_core_1.uuid)('thread_id').notNull(), // FK to threads(id) ON DELETE CASCADE
    ownerUserId: (0, pg_core_1.uuid)('owner_user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE
    requestId: (0, pg_core_1.uuid)('request_id'), // NEW: FK to agent_requests(id) ON DELETE CASCADE (optional, set later)
    toolName: (0, pg_core_1.text)('tool_name').notNull(), // 'write_file', 'create_branch', etc
    toolInput: (0, pg_core_1.jsonb)('tool_input').notNull(),
    approvalStatus: (0, pg_core_1.text)('approval_status').default('pending'), // 'pending', 'approved', 'rejected'
    toolOutput: (0, pg_core_1.jsonb)('tool_output'), // Result of tool execution
    rejectionReason: (0, pg_core_1.text)('rejection_reason'), // Why tool was rejected
    revisionCount: (0, pg_core_1.integer)('revision_count').default(0), // Number of rejection + retry cycles
    revisionHistory: (0, pg_core_1.jsonb)('revision_history').default([]), // NEW: Track revision attempts
    timestamp: (0, pg_core_1.timestamp)('timestamp', { withTimezone: true }).defaultNow().notNull(),
}, function (table) { return ({
    idIdx: (0, pg_core_1.index)('idx_agent_tool_calls_id').on(table.id),
    threadIdIdx: (0, pg_core_1.index)('idx_agent_tool_calls_thread_id').on(table.threadId),
    messageIdIdx: (0, pg_core_1.index)('idx_agent_tool_calls_message_id').on(table.messageId),
    requestIdIdx: (0, pg_core_1.index)('idx_agent_tool_calls_request_id').on(table.requestId), // NEW
    approvalStatusIdx: (0, pg_core_1.index)('idx_agent_tool_calls_approval_status').on(table.approvalStatus),
    ownerUserIdIdx: (0, pg_core_1.index)('idx_agent_tool_calls_owner_user_id').on(table.ownerUserId),
    createdAtIdx: (0, pg_core_1.index)('idx_agent_tool_calls_created_at').on(table.timestamp),
}); });
// ============================================================================
// 11. CONTEXT_REFERENCES TABLE (Agent System)
// ============================================================================
exports.contextReferences = (0, pg_core_1.pgTable)('context_references', {
    id: (0, pg_core_1.uuid)('id').primaryKey().defaultRandom(),
    threadId: (0, pg_core_1.uuid)('thread_id').notNull(), // FK to threads(id) ON DELETE CASCADE
    ownerUserId: (0, pg_core_1.uuid)('owner_user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE
    entityType: (0, pg_core_1.text)('entity_type').notNull(), // 'file', 'document', 'thread', etc
    entityReference: (0, pg_core_1.text)('entity_reference').notNull(), // path or ID of referenced entity
    source: (0, pg_core_1.text)('source').notNull(), // 'user-added', 'agent-added', 'inherited', etc
    priorityTier: (0, pg_core_1.integer)('priority_tier').default(1), // Higher = more important for context
    addedAt: (0, pg_core_1.timestamp)('added_at', { withTimezone: true }).defaultNow().notNull(),
}, function (table) { return ({
    threadIdIdx: (0, pg_core_1.index)('idx_context_references_thread_id').on(table.threadId),
    ownerUserIdIdx: (0, pg_core_1.index)('idx_context_references_owner_user_id').on(table.ownerUserId),
    entityTypeIdx: (0, pg_core_1.index)('idx_context_references_entity_type').on(table.entityType),
}); });
// ============================================================================
// 12. FILES TABLE (Agent System)
// ============================================================================
exports.files = (0, pg_core_1.pgTable)('files', {
    id: (0, pg_core_1.uuid)('id').primaryKey().defaultRandom(),
    ownerUserId: (0, pg_core_1.uuid)('owner_user_id').notNull(), // FK to auth.users(id) ON DELETE CASCADE
    path: (0, pg_core_1.text)('path').notNull(), // File path in workspace
    content: (0, pg_core_1.text)('content').notNull(), // File content
    isAIGenerated: (0, pg_core_1.boolean)('is_ai_generated').default(false), // Track AI-generated files
    createdBy: (0, pg_core_1.text)('created_by'), // 'user' or agent name
    lastEditedBy: (0, pg_core_1.text)('last_edited_by'),
    lastEditedAt: (0, pg_core_1.timestamp)('last_edited_at', { withTimezone: true }),
    createdAt: (0, pg_core_1.timestamp)('created_at', { withTimezone: true }).defaultNow().notNull(),
    updatedAt: (0, pg_core_1.timestamp)('updated_at', { withTimezone: true }).defaultNow().notNull(),
}, function (table) { return ({
    ownerUserIdIdx: (0, pg_core_1.index)('idx_files_owner_user_id').on(table.ownerUserId),
    pathIdx: (0, pg_core_1.index)('idx_files_path').on(table.path),
    userPathIdx: (0, pg_core_1.index)('idx_files_user_path').on(table.ownerUserId, table.path),
    isAIGeneratedIdx: (0, pg_core_1.index)('idx_files_is_ai_generated').on(table.isAIGenerated),
    createdAtIdx: (0, pg_core_1.index)('idx_files_created_at').on(table.createdAt),
}); });
// ============================================================================
// RLS POLICIES (Applied via migration SQL)
// ============================================================================
// These SQL statements will be added to migrations for RLS policies
// Drizzle ORM doesn't have native RLS support, so we define these separately
exports.rlsPolicies = {
    userProfiles: "\n    -- Enable RLS on user_profiles\n    ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;\n\n    -- Users can view own profile\n    CREATE POLICY \"Users can view own profile\"\n      ON user_profiles FOR SELECT\n      USING (auth.uid() = user_id);\n\n    -- Users can update own profile\n    CREATE POLICY \"Users can update own profile\"\n      ON user_profiles FOR UPDATE\n      USING (auth.uid() = user_id);\n  ",
    folders: "\n    -- Enable RLS on folders\n    ALTER TABLE folders ENABLE ROW LEVEL SECURITY;\n\n    -- Users can read only their own folders\n    CREATE POLICY \"Users can read own folders\"\n      ON folders FOR SELECT\n      USING (auth.uid() = user_id);\n\n    -- Users can insert folders into their own hierarchy\n    CREATE POLICY \"Users can create own folders\"\n      ON folders FOR INSERT\n      WITH CHECK (auth.uid() = user_id);\n\n    -- Users can update their own folders\n    CREATE POLICY \"Users can update own folders\"\n      ON folders FOR UPDATE\n      USING (auth.uid() = user_id);\n\n    -- Users can delete their own folders (cascade to children via FK)\n    CREATE POLICY \"Users can delete own folders\"\n      ON folders FOR DELETE\n      USING (auth.uid() = user_id);\n  ",
    documents: "\n    -- Enable RLS on documents\n    ALTER TABLE documents ENABLE ROW LEVEL SECURITY;\n\n    -- Users can view own documents\n    CREATE POLICY \"Users can view own documents\"\n      ON documents FOR SELECT\n      USING (auth.uid() = user_id);\n\n    -- Users can insert own documents\n    CREATE POLICY \"Users can insert own documents\"\n      ON documents FOR INSERT\n      WITH CHECK (auth.uid() = user_id);\n\n    -- Users can update own documents\n    CREATE POLICY \"Users can update own documents\"\n      ON documents FOR UPDATE\n      USING (auth.uid() = user_id);\n\n    -- Users can delete own documents\n    CREATE POLICY \"Users can delete own documents\"\n      ON documents FOR DELETE\n      USING (auth.uid() = user_id);\n  ",
    documentChunks: "\n    -- Enable RLS on document_chunks\n    ALTER TABLE document_chunks ENABLE ROW LEVEL SECURITY;\n\n    -- Users can view chunks of own documents\n    CREATE POLICY \"Users can view chunks of own documents\"\n      ON document_chunks FOR SELECT\n      USING (EXISTS (\n        SELECT 1 FROM documents\n        WHERE documents.id = document_chunks.document_id\n        AND documents.user_id = auth.uid()\n      ));\n\n    -- Users can insert chunks for own documents\n    CREATE POLICY \"Users can insert chunks for own documents\"\n      ON document_chunks FOR INSERT\n      WITH CHECK (EXISTS (\n        SELECT 1 FROM documents\n        WHERE documents.id = document_chunks.document_id\n        AND documents.user_id = auth.uid()\n      ));\n\n    -- Users can update chunks of own documents\n    CREATE POLICY \"Users can update chunks of own documents\"\n      ON document_chunks FOR UPDATE\n      USING (EXISTS (\n        SELECT 1 FROM documents\n        WHERE documents.id = document_chunks.document_id\n        AND documents.user_id = auth.uid()\n      ));\n\n    -- Users can delete chunks of own documents\n    CREATE POLICY \"Users can delete chunks of own documents\"\n      ON document_chunks FOR DELETE\n      USING (EXISTS (\n        SELECT 1 FROM documents\n        WHERE documents.id = document_chunks.document_id\n        AND documents.user_id = auth.uid()\n      ));\n  ",
    agentRequests: "\n    -- Enable RLS on agent_requests\n    ALTER TABLE agent_requests ENABLE ROW LEVEL SECURITY;\n\n    -- Users can view own requests\n    CREATE POLICY \"Users can view own agent requests\"\n      ON agent_requests FOR SELECT\n      USING (auth.uid() = user_id);\n\n    -- Users can insert own requests\n    CREATE POLICY \"Users can insert own agent requests\"\n      ON agent_requests FOR INSERT\n      WITH CHECK (auth.uid() = user_id);\n\n    -- Users can update own requests\n    CREATE POLICY \"Users can update own agent requests\"\n      ON agent_requests FOR UPDATE\n      USING (auth.uid() = user_id);\n\n    -- Users can delete own requests\n    CREATE POLICY \"Users can delete own agent requests\"\n      ON agent_requests FOR DELETE\n      USING (auth.uid() = user_id);\n  ",
    agentSessions: "\n    -- Enable RLS on agent_sessions\n    ALTER TABLE agent_sessions ENABLE ROW LEVEL SECURITY;\n\n    -- Users can view own sessions\n    CREATE POLICY \"Users can view own agent sessions\"\n      ON agent_sessions FOR SELECT\n      USING (auth.uid() = user_id);\n\n    -- Users can insert own sessions\n    CREATE POLICY \"Users can insert own agent sessions\"\n      ON agent_sessions FOR INSERT\n      WITH CHECK (auth.uid() = user_id);\n\n    -- Users can update own sessions\n    CREATE POLICY \"Users can update own agent sessions\"\n      ON agent_sessions FOR UPDATE\n      USING (auth.uid() = user_id);\n\n    -- Users can delete own sessions\n    CREATE POLICY \"Users can delete own agent sessions\"\n      ON agent_sessions FOR DELETE\n      USING (auth.uid() = user_id);\n  ",
    usageEvents: "\n    -- Enable RLS on usage_events\n    ALTER TABLE usage_events ENABLE ROW LEVEL SECURITY;\n\n    -- Users can view own usage events\n    CREATE POLICY \"Users can view own usage events\"\n      ON usage_events FOR SELECT\n      USING (auth.uid() = user_id);\n\n    -- Users can insert own usage events\n    CREATE POLICY \"Users can insert own usage events\"\n      ON usage_events FOR INSERT\n      WITH CHECK (auth.uid() = user_id);\n\n    -- No UPDATE or DELETE allowed (immutable audit trail)\n  ",
};
// ============================================================================
// TRIGGERS (Applied via migration SQL)
// ============================================================================
exports.triggers = {
    // Automatic updated_at timestamp update
    updateUpdatedAt: "\n    CREATE OR REPLACE FUNCTION update_updated_at_column()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      NEW.updated_at = NOW();\n      RETURN NEW;\n    END;\n    $$ LANGUAGE plpgsql;\n\n    -- Apply to all tables with updated_at\n    CREATE TRIGGER update_user_profiles_updated_at\n      BEFORE UPDATE ON user_profiles\n      FOR EACH ROW\n      EXECUTE FUNCTION update_updated_at_column();\n\n    CREATE TRIGGER update_folders_updated_at\n      BEFORE UPDATE ON folders\n      FOR EACH ROW\n      EXECUTE FUNCTION update_updated_at_column();\n\n    CREATE TRIGGER update_documents_updated_at\n      BEFORE UPDATE ON documents\n      FOR EACH ROW\n      EXECUTE FUNCTION update_updated_at_column();\n\n    CREATE TRIGGER update_document_chunks_updated_at\n      BEFORE UPDATE ON document_chunks\n      FOR EACH ROW\n      EXECUTE FUNCTION update_updated_at_column();\n\n    CREATE TRIGGER update_agent_requests_updated_at\n      BEFORE UPDATE ON agent_requests\n      FOR EACH ROW\n      EXECUTE FUNCTION update_updated_at_column();\n\n    CREATE TRIGGER update_agent_sessions_updated_at\n      BEFORE UPDATE ON agent_sessions\n      FOR EACH ROW\n      EXECUTE FUNCTION update_updated_at_column();\n  ",
    // Auto-create user profile on auth.users insert
    // NOTE: For MVP account foundation, Edge Function handles profile creation explicitly
    // with atomic rollback logic (research.md). This trigger is DISABLED to avoid conflicts.
    // Re-enable post-MVP if Edge Function approach is replaced.
    autoCreateProfile: "\n    -- DISABLED: Edge Function handles profile creation with rollback\n    -- CREATE OR REPLACE FUNCTION create_user_profile()\n    -- RETURNS TRIGGER AS $$\n    -- BEGIN\n    --   INSERT INTO user_profiles (user_id, first_name, last_name)\n    --   VALUES (\n    --     NEW.id,\n    --     NEW.raw_user_meta_data->>'first_name',\n    --     NEW.raw_user_meta_data->>'last_name'\n    --   );\n    --   RETURN NEW;\n    -- END;\n    -- $$ LANGUAGE plpgsql;\n\n    -- CREATE TRIGGER on_auth_user_created\n    --   AFTER INSERT ON auth.users\n    --   FOR EACH ROW\n    --   EXECUTE FUNCTION create_user_profile();\n  ",
    // Full-text search vector generation
    // NOTE: tsvector columns defined in schema using customType
    // Triggers and indexes applied via this SQL
    searchVectors: "\n    -- Create GIN indexes for full-text search performance\n    CREATE INDEX IF NOT EXISTS documents_search_vector_idx\n      ON documents USING GIN (search_vector);\n\n    CREATE INDEX IF NOT EXISTS document_chunks_search_vector_idx\n      ON document_chunks USING GIN (search_vector);\n\n    -- Create triggers to auto-update search vectors on INSERT/UPDATE\n    DROP TRIGGER IF EXISTS update_documents_search_vector ON documents;\n    CREATE TRIGGER update_documents_search_vector\n      BEFORE INSERT OR UPDATE OF content_text ON documents\n      FOR EACH ROW\n      EXECUTE FUNCTION tsvector_update_trigger(search_vector, 'pg_catalog.english', content_text);\n\n    DROP TRIGGER IF EXISTS update_chunks_search_vector ON document_chunks;\n    CREATE TRIGGER update_chunks_search_vector\n      BEFORE INSERT OR UPDATE OF content ON document_chunks\n      FOR EACH ROW\n      EXECUTE FUNCTION tsvector_update_trigger(search_vector, 'pg_catalog.english', content);\n  ",
};
// ============================================================================
// CASCADE DELETE FOREIGN KEYS
// ============================================================================
// These foreign keys to auth.users must be added separately since auth schema
// is not managed by Drizzle. Apply this SQL after pushing schema with drizzle-kit.
// Usage: Run cascadeDeleteSQL via database client or Supabase Dashboard SQL Editor
exports.cascadeDeleteSQL = "\n-- Add CASCADE DELETE foreign keys for GDPR compliance\n\n-- User Profiles\nALTER TABLE user_profiles\n  DROP CONSTRAINT IF EXISTS user_profiles_user_id_fkey;\nALTER TABLE user_profiles\n  ADD CONSTRAINT user_profiles_user_id_fkey\n  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;\n\n-- Folders (user ownership + self-referential hierarchy)\nALTER TABLE folders\n  DROP CONSTRAINT IF EXISTS folders_user_id_fkey;\nALTER TABLE folders\n  ADD CONSTRAINT folders_user_id_fkey\n  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;\n\nALTER TABLE folders\n  DROP CONSTRAINT IF EXISTS folders_parent_folder_id_fkey;\nALTER TABLE folders\n  ADD CONSTRAINT folders_parent_folder_id_fkey\n  FOREIGN KEY (parent_folder_id) REFERENCES folders(id) ON DELETE CASCADE;\n\n-- Documents (user ownership + folder hierarchy)\nALTER TABLE documents\n  DROP CONSTRAINT IF EXISTS documents_user_id_fkey;\nALTER TABLE documents\n  ADD CONSTRAINT documents_user_id_fkey\n  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;\n\nALTER TABLE documents\n  DROP CONSTRAINT IF EXISTS documents_folder_id_fkey;\nALTER TABLE documents\n  ADD CONSTRAINT documents_folder_id_fkey\n  FOREIGN KEY (folder_id) REFERENCES folders(id) ON DELETE CASCADE;\n\n-- Document Chunks (cascade from documents)\nALTER TABLE document_chunks\n  DROP CONSTRAINT IF EXISTS document_chunks_document_id_fkey;\nALTER TABLE document_chunks\n  ADD CONSTRAINT document_chunks_document_id_fkey\n  FOREIGN KEY (document_id) REFERENCES documents(id) ON DELETE CASCADE;\n\n-- Agent Requests\nALTER TABLE agent_requests\n  DROP CONSTRAINT IF EXISTS agent_requests_user_id_fkey;\nALTER TABLE agent_requests\n  ADD CONSTRAINT agent_requests_user_id_fkey\n  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;\n\n-- Agent Requests - Thread FK (NEW)\nALTER TABLE agent_requests\n  DROP CONSTRAINT IF EXISTS agent_requests_thread_id_fkey;\nALTER TABLE agent_requests\n  ADD CONSTRAINT agent_requests_thread_id_fkey\n  FOREIGN KEY (thread_id) REFERENCES threads(id) ON DELETE CASCADE;\n\n-- Agent Requests - Triggering Message FK (NEW)\nALTER TABLE agent_requests\n  DROP CONSTRAINT IF EXISTS agent_requests_triggering_message_id_fkey;\nALTER TABLE agent_requests\n  ADD CONSTRAINT agent_requests_triggering_message_id_fkey\n  FOREIGN KEY (triggering_message_id) REFERENCES messages(id) ON DELETE CASCADE;\n\n-- Agent Requests - Response Message FK (NEW, optional)\nALTER TABLE agent_requests\n  DROP CONSTRAINT IF EXISTS agent_requests_response_message_id_fkey;\nALTER TABLE agent_requests\n  ADD CONSTRAINT agent_requests_response_message_id_fkey\n  FOREIGN KEY (response_message_id) REFERENCES messages(id) ON DELETE SET NULL;\n\n-- Agent Tool Calls - Agent Request FK (NEW)\nALTER TABLE agent_tool_calls\n  DROP CONSTRAINT IF EXISTS agent_tool_calls_request_id_fkey;\nALTER TABLE agent_tool_calls\n  ADD CONSTRAINT agent_tool_calls_request_id_fkey\n  FOREIGN KEY (request_id) REFERENCES agent_requests(id) ON DELETE CASCADE;\n\n-- Agent Sessions\nALTER TABLE agent_sessions\n  DROP CONSTRAINT IF EXISTS agent_sessions_user_id_fkey;\nALTER TABLE agent_sessions\n  ADD CONSTRAINT agent_sessions_user_id_fkey\n  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;\n\n-- Usage Events\nALTER TABLE usage_events\n  DROP CONSTRAINT IF EXISTS usage_events_user_id_fkey;\nALTER TABLE usage_events\n  ADD CONSTRAINT usage_events_user_id_fkey\n  FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;\n\n-- Verify CASCADE constraints\nSELECT\n  conname AS constraint_name,\n  conrelid::regclass AS table_name,\n  confrelid::regclass AS references_table\nFROM pg_constraint\nWHERE confdeltype = 'c'  -- 'c' = CASCADE\nORDER BY conname;\n";
// ============================================================================
// PGVECTOR EXTENSION (Vector Embeddings for RAG)
// ============================================================================
// Enable pgvector extension and add embedding column to document_chunks
// Must be run after initial schema push
exports.pgvectorSQL = "\n-- Enable pgvector extension for vector similarity search\nCREATE EXTENSION IF NOT EXISTS vector;\n\n-- Add embedding column to document_chunks table\nALTER TABLE document_chunks\nADD COLUMN IF NOT EXISTS embedding vector(1536);\n\n-- Create HNSW index for fast vector similarity search\nCREATE INDEX IF NOT EXISTS document_chunks_embedding_idx\nON document_chunks\nUSING hnsw (embedding vector_cosine_ops);\n";
// ============================================================================
// REALTIME PUBLICATION
// ============================================================================
// Enable realtime for tables that need real-time subscriptions
// Must be run after schema push
exports.realtimePublicationSQL = "\n-- Enable realtime for all tables (for streaming updates)\n-- Uses SET TABLE instead of ADD TABLE for idempotency\nALTER PUBLICATION supabase_realtime SET TABLE\n  agent_requests,\n  agent_execution_events,\n  agent_sessions,\n  documents,\n  document_chunks,\n  folders,\n  threads,\n  messages,\n  context_references,\n  files,\n  user_profiles;\n\n-- CRITICAL: Set REPLICA IDENTITY to FULL for DELETE events\n-- Default behavior: DELETE events only include primary key (id)\n-- FULL behavior: DELETE events include all columns (including user_id)\n-- Why needed: Subscription filters need user_id and other columns for authorization\nALTER TABLE agent_requests REPLICA IDENTITY FULL;\nALTER TABLE agent_execution_events REPLICA IDENTITY FULL;\nALTER TABLE agent_sessions REPLICA IDENTITY FULL;\nALTER TABLE documents REPLICA IDENTITY FULL;\nALTER TABLE document_chunks REPLICA IDENTITY FULL;\nALTER TABLE folders REPLICA IDENTITY FULL;\nALTER TABLE threads REPLICA IDENTITY FULL;\nALTER TABLE messages REPLICA IDENTITY FULL;\nALTER TABLE context_references REPLICA IDENTITY FULL;\nALTER TABLE files REPLICA IDENTITY FULL;\nALTER TABLE user_profiles REPLICA IDENTITY FULL;\n";
